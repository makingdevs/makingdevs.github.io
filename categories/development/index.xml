<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on Blog de Making Devs</title>
    <link>http://blog.makingdevs.com/categories/development/</link>
    <description>Recent content in Development on Blog de Making Devs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Sep 2016 11:22:01 -0500</lastBuildDate>
    <atom:link href="http://blog.makingdevs.com/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Routing en Elm</title>
      <link>http://blog.makingdevs.com/2016/09/10/routing-en-elm</link>
      <pubDate>Sat, 10 Sep 2016 11:22:01 -0500</pubDate>
      
      <guid>http://blog.makingdevs.com/2016/09/10/routing-en-elm</guid>
      <description>

&lt;p&gt;La URL es un bit interesante de nuestra applicación, nos permite regresar a un estado, o compartir ese estado con alguien más; y en Elm, el Routing, es la segunda cosa más importante que deberías conocer después del propio lenguaje. Así que empecemos.&lt;/p&gt;

&lt;h3 id=&#34;anatomía-de-una-url:298460950b7ccdfaea249eb4d57a4fbe&#34;&gt;ANATOMÍA DE UNA URL&lt;/h3&gt;

&lt;p&gt;Una URL es una dirección dada para un recurso único en la web y está compuesta de diferentes partes: un protocolo, un host, un nombre de dominio, opcionalmente un path y el nombre del archivo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http_URL = &amp;quot;http:&amp;quot; &amp;quot;//&amp;quot; host [&amp;quot;:&amp;quot; port][ abs_path [&amp;quot;?&amp;quot; query ]]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para el caso del routing en Elm sólo nos incumben aquellas que pueden ser opcionales.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[ abs_path [&amp;quot;?&amp;quot; query ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Teniendo esto en mente, continuemos.&lt;/p&gt;

&lt;h3 id=&#34;instalando-dependencias:298460950b7ccdfaea249eb4d57a4fbe&#34;&gt;INSTALANDO DEPENDENCIAS&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Vamos a necesitar esta biblioteca para controlar la navegación.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;elm package install elm-lang/navigation&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Y esta otra para transformar nuestras URLs en estructuras de datos agradables.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;elm package navigation evancz/url-parser&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Por último necesitaremos la función &lt;code&gt;Navigation.program&lt;/code&gt; que vive dentro del módulo &lt;code&gt;Navigation&lt;/code&gt;, su tarea será tomar el &lt;code&gt;parser&lt;/code&gt; y un &lt;code&gt;record&lt;/code&gt; para poder regresarnos un programa Elm.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;empieza-configurando-la-aplicación:298460950b7ccdfaea249eb4d57a4fbe&#34;&gt;EMPIEZA CONFIGURANDO LA APLICACIÓN&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Navigation.program&lt;/code&gt; nos proveé de una función &lt;code&gt;urlUpdate&lt;/code&gt; para actualizar el modelo cada que el &lt;code&gt;parser&lt;/code&gt;produzca nuevos datos.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/gothwski/7bfeec986a90d34eb283830d8903081f.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;define-las-rutas:298460950b7ccdfaea249eb4d57a4fbe&#34;&gt;DEFINE LAS RUTAS.&lt;/h3&gt;

&lt;p&gt;Es importante mencionar que el orden de los matchers importa, para más detalle sobre ello revisa la &lt;a href=&#34;http://package.elm-lang.org/packages/evancz/url-parser/latest/&#34;&gt;documentación&lt;/a&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/gothwski/7bfeec986a90d34eb283830d8903081f.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;así-es-como-funciona-y-se-implementa:298460950b7ccdfaea249eb4d57a4fbe&#34;&gt;ASÍ ES COMO FUNCIONA&amp;hellip; Y SE IMPLEMENTA.&lt;/h3&gt;

&lt;p&gt;Cuando queremos acceder a un documento en particular de un servidor web, escribimos una &lt;code&gt;URL&lt;/code&gt; en la location bar, y un par de cosas suceden: primeramente la URL es partida en sus diferentes partes. Es entonces cuando la biblioteca &lt;code&gt;Navigation&lt;/code&gt; nos genera un record &lt;code&gt;Navigation.Location&lt;/code&gt; con dos partes de ella: el Path y los Parámetros, e inmediatamente manda llamar al &lt;code&gt;parser&lt;/code&gt; quien será el responsable de transformar esa &lt;code&gt;URL&lt;/code&gt; de tipo &lt;code&gt;String&lt;/code&gt; en datos útiles.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/gothwski/7bfeec986a90d34eb283830d8903081f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Es entonces cuando este record es tomado por una función llamada &lt;code&gt;hashParser&lt;/code&gt; que enviará el &lt;code&gt;string&lt;/code&gt; resultante a la función &lt;code&gt;Navigation.makeParser&lt;/code&gt;que vive dentro de &lt;code&gt;parser&lt;/code&gt;, y así mismo se incluirán como párametro las rutas que ya hemos definido anteriormente:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/gothwski/7bfeec986a90d34eb283830d8903081f.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Finalmente el &lt;code&gt;parser&lt;/code&gt; regresa un resultado, si es &lt;code&gt;OK&lt;/code&gt; nos devolerá la ruta que hace match y definiremos la acción correspondiente, de lo contrario caeremos en el &lt;code&gt;error&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;//gist.github.com/gothwski/7bfeec986a90d34eb283830d8903081f.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Borrado batch en Grails</title>
      <link>http://blog.makingdevs.com/2015/05/01/borrado-batch-en-grails</link>
      <pubDate>Fri, 01 May 2015 20:58:30 -0500</pubDate>
      
      <guid>http://blog.makingdevs.com/2015/05/01/borrado-batch-en-grails</guid>
      <description>

&lt;p&gt;En esta ocasión les quiero compartir la solución a un problema que tuve al borrar una colección de objetos en grails y con el GORM, si bien podría hacerlo con HQL o con SQL usando las bondades de Hibernate me gusto más el acercamiento que les quiero presentar.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;La necesidad era borrar un grupo de objetos en donde el contenido de su relación estuviera vacío, ejemplifico con la estructura de unas clases:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/neodevelop/54953d90cc778b71548a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;El primer acercamiento que tuve fue obtener la lista de elementos y hacer una condicional buscando los elementos vacíos, después borrar&amp;hellip;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/neodevelop/54953d90cc778b71548a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Una vez hecho, mejoramos intentamos mejorar el código con una búsqueda mucho más refinada y ejecutando el borrado, para ello nos apoyamos de los &lt;strong&gt;where queries&lt;/strong&gt;:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/neodevelop/54953d90cc778b71548a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Basado en la documentación de Grails:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Since each where method call returns a DetachedCriteria instance, you can use where queries to execute batch operations such as batch updates and deletes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sin embargo, este acercamiento tiene un problema, manda un error cuando se busca por las relaciones del objeto y no permite el borrado. El error: &lt;code&gt;org.springframework.dao.InvalidDataAccessResourceUsageException: Queries of type SizeEquals are not supported by this implementation&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;la-solución-que-me-gustó:e9e6169eb5bad18820f609521078ca60&#34;&gt;La solución que me gustó&lt;/h3&gt;

&lt;p&gt;Usamos &lt;strong&gt;Detached Criteria&lt;/strong&gt; para resolver este problema, por que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No están asociados con una sesión o conexión, lo cual permite formularlos y reusarlos.&lt;/li&gt;
&lt;li&gt;También cuenta con métodos batch: &lt;code&gt;deleteAll&lt;/code&gt;, &lt;code&gt;updateAll&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Permiten proyecciones y subqueries, que es lo que estamos buscando para resolver nuestro problema&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finalmente nuestra solución es:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/neodevelop/54953d90cc778b71548a.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Con esto, tenemos una búsqueda refinada y el borrado de los elementos directo, inclusive el método &lt;code&gt;deleteAll&lt;/code&gt; regresa un entero con la cantidad de registros afectados.&lt;/p&gt;

&lt;p&gt;Esto me fue de mucha utilidad y ojalá también lo sea para ustedes en algún momento.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clusterizacion con Camel</title>
      <link>http://blog.makingdevs.com/2015/04/07/clusterizacion-con-camel</link>
      <pubDate>Tue, 07 Apr 2015 19:56:54 -0500</pubDate>
      
      <guid>http://blog.makingdevs.com/2015/04/07/clusterizacion-con-camel</guid>
      <description>&lt;p&gt;Camel ofrece distintas soluciones para ser escalado o para distribuir la carga en diferentes instancias, la soluciones que ofrece dependerá de como se encuentra nuestra infraestructura ( y configuración).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Misma JVM y CamelContext&lt;/li&gt;
&lt;li&gt;Misma JVM pero diferente CamelContext&lt;/li&gt;
&lt;li&gt;Diferente JVM y CamelContext
&lt;!-- more --&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El problema que me vi envuelto fue de estas tres, la ultima, el clusterizar camel que se encontraban en diferentes JVM y CamelContext. Y en particular tuve un problema de mensajes duplicados. Para esto camel ofrece ciertas soluciones, un componente llamado &lt;strong&gt;Idempotent Consumer&lt;/strong&gt;. El Idempotent Consumer pertenece a los patrones de EIP se usa para filtrar los mensajes duplicados. Este modelo se implementa utilizando la clase IdempotentConsumer. Este utiliza una expresión para calcular una cadena de mensaje ID único para un intercambio de mensajes, este ID puede ser consultado en la IdempotentRepository para ver si se ha visto antes, si se tiene no es tomado para ser procesado, en cambio si no se tiene, entonces el mensaje se procesa y la ID se añade al repositorio.&lt;/p&gt;

&lt;p&gt;Hay varios tipos de IdempotentRepository:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MemoryIdempotentRepository&lt;/li&gt;
&lt;li&gt;FileIdempotentRepository&lt;/li&gt;
&lt;li&gt;HazelcastIdempotentRepository (Available as of Camel 2.8)&lt;/li&gt;
&lt;li&gt;JdbcMessageIdRepository (Available as of Camel 2.7)&lt;/li&gt;
&lt;li&gt;JpaMessageIdRepository&lt;/li&gt;
&lt;/ul&gt;



@Grab(group=&#39;org.slf4j&#39;, module=&#39;slf4j-api&#39;, version=&#39;1.7.10&#39;)
@Grab(group=&#39;org.apache.camel&#39;, module=&#39;camel-core&#39;, version=&#39;2.12.0&#39;)
@Grab(group=&#39;org.apache.camel&#39;, module=&#39;camel-mail&#39;, version=&#39;2.12.0&#39;)

import org.apache.camel.impl.DefaultCamelContext
import org.apache.camel.builder.RouteBuilder
import org.apache.camel.processor.idempotent.FileIdempotentRepository

def camelContext = new DefaultCamelContext()
camelContext.addRoutes(new RouteBuilder() {
  def void configure() {
    from(&#34;imaps://imap.gmail.com?username=jorge@makingdevs.com&#34;
      + &#34;&amp;password=m4k1ngd3vs&#34;
      + &#34;&amp;consumer.delay=6000&#34;)
    .idempotentConsumer( header(&#34;Message-ID&#34;),
      FileIdempotentRepository.fileIdempotentRepository(
        new File(&#34;idempotentRepository.txt&#34;)))
    .to(&#34;log:groovymail?showAll=true&amp;multiline=true&#34;) } })

camelContext.start()
addShutdownHook{ camelContext.stop() }
synchronized(this){ this.wait() }


&lt;p&gt;Este es un script ejemplo el cual utiliza &lt;code&gt;FileIdempotentRepository&lt;/code&gt; utilizando un archivo ejemplo para llevar el control, si exploramos el archivo ahí se encuentra los id de los mensajes procesados.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.makingdevs.com/images/camel_output.png&#34; alt=&#34;Camel output&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Asi si hay un mensaje el cual ya se encuentra dentro de este archivo se ignora y no es procesado. En mi caso utilize JpaMessageIdRepository dentro de grails y fue muy simple utilizar este componente solo agregue la dependencia de camel sql en el buildConfig.groovy&lt;/p&gt;

&lt;p&gt;
runtime &#39;org.apache.camel:camel-sql:2.13.0’
&lt;/p&gt;

&lt;p&gt;y agregue el bean en resources.groovy&lt;/p&gt;

&lt;p&gt;
import org.apache.camel.processor.idempotent.jdbc.JdbcMessageIdRepository

beans = {
  messageIdRepository(JdbcMessageIdRepository,ref(&#39;dataSource&#39;),&#39;jdbcProcessorName&#39;)
}
&lt;/p&gt;

&lt;p&gt;y por ultimo agregue el &lt;em&gt;idempotentComponent&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Personalizar notificaciones de correo en Jenkins</title>
      <link>http://blog.makingdevs.com/2014/11/06/personalizar-notificaciones-de-correo-en-jenkins</link>
      <pubDate>Thu, 06 Nov 2014 19:08:56 -0500</pubDate>
      
      <guid>http://blog.makingdevs.com/2014/11/06/personalizar-notificaciones-de-correo-en-jenkins</guid>
      <description>&lt;p&gt;Las &lt;strong&gt;notificaciones&lt;/strong&gt; son básicas para la correcta comunicación de los involucrados de nuestros proyectos como: &lt;em&gt;Stakeholders/ Key Users / Developers / Clientes / Testers&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Por esta razón te recomiendo personalizar las notificaciones por defecto de &lt;strong&gt;Jenkins&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Objetivo: Informar los despliegues desde Jenkins por correo, usando el &lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+plugin&#34;&gt;plugin: Email-ext&lt;/a&gt;&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;Procedimiento:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instalar el plugin desde la consola de administración de Jenkins. &lt;img src=&#34;http://blog.makingdevs.com/images/IC-Jenkins-PlugIn-Email-Ext_01.jpg&#34; alt=&#34;Screenshot 1&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configurar la cuenta de correo saliente SMTP, te recomiendo que uses el autenticado.&lt;img src=&#34;http://blog.makingdevs.com/images/IC-Jenkins-PlugIn-Email-Ext_02.jpg&#34; alt=&#34;Screenshot 2&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configurar el plugin: Email-ext con información base de los usuarios a notificar ( &lt;em&gt;Stake Holders/ Key Users / Developers / Clientes / Testers&lt;/em&gt; ) en las listas por DEFAULT de la configuración general a nivel. Esto te permitirá contar con la misma configuración para tus N tareas de despliegue. &lt;img src=&#34;http://blog.makingdevs.com/images/IC-Jenkins-PlugIn-Email-Ext_03.jpg&#34; alt=&#34;Screenshot 3&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Para personalizar el correo que se enviará, copiaremos un&lt;strong&gt;Template&lt;/strong&gt; dentro del Home de Jenkins, &lt;em&gt;static-analysis.jelly&lt;/em&gt; y asignando nombre relacionado al proyecto. Si requieres más información, consulta la &lt;a href=&#34;https://github.com/jenkinsci/email-ext-plugin/tree/master/src/main/resources/hudson/plugins/emailext/templates&#34;&gt;documentación del plugin en GitHub&lt;/a&gt;. Este template es un &lt;strong&gt;HTML el cual puedes editar su contenido&lt;/strong&gt;, incluyendo titulo del proyecto, una imagen, etc. &lt;img src=&#34;http://blog.makingdevs.com/images/IC-Jenkins-PlugIn-Email-Ext_04.jpg&#34; alt=&#34;Screenshot 4&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Añade en una tarea de Jenkins, un paso al finalizar, usando Email notification. &lt;img src=&#34;http://blog.makingdevs.com/images/IC-Jenkins-PlugIn-Email-Ext_05.jpg&#34; alt=&#34;Screenshot 5&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ejecuta tu tarea y verifica el correo recibido. &lt;img src=&#34;http://blog.makingdevs.com/images/IC-Jenkins-PlugIn-Email-Ext_06.jpg&#34; alt=&#34;Screenshot 6&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Inyección de métodos por categorías y TimeCategory</title>
      <link>http://blog.makingdevs.com/2014/09/16/inyecci%C3%B3n-de-m%C3%A9todos-por-categor%C3%ADas-y-timecategory</link>
      <pubDate>Tue, 16 Sep 2014 18:55:30 -0500</pubDate>
      
      <guid>http://blog.makingdevs.com/2014/09/16/inyecci%C3%B3n-de-m%C3%A9todos-por-categor%C3%ADas-y-timecategory</guid>
      <description>

&lt;h2 id=&#34;acerca-de-las-categorías:e62c0560695f1f5c3ac7c5a60edd4eb3&#34;&gt;Acerca de las categorías&lt;/h2&gt;

&lt;p&gt;En Groovy se pueden inyectar métodos de algunas formas, uno de ellos es a través del uso de categorías, la cual nos da inyección temporal y controlada de dichos elementos. Para hacerlo las clases que son categorías deben de cumplir con cierta estructura:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Los métodos de la clase deben ser definidos como estáticos&lt;/li&gt;
&lt;li&gt;El primer argumento de dicho método define el tipo sobre el cual se inyectarían los nuevos métodos&lt;/li&gt;
&lt;li&gt;Deben de ser usados dentro del alcance de un closure con ayuda de la palabra reservada &lt;code&gt;use&lt;/code&gt;
&lt;!-- more --&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un ejemplo podría ser el siguiente:&lt;/p&gt;


    class NameUtil{
        static prettify(String name){
            name.trim().split(&#39; &#39;).grep { it.size() }*.capitalize().join(&#39; &#39;)
        }
    }

    use NameUtil, {
        println &#34;  josé   juan    reyes    zuñiga   &#34;.prettify()
    }


&lt;p&gt;Adicionalmente, podemos crear dicha inyección de métodos con ayuda de la anotación &lt;code&gt;@Category&lt;/code&gt;, que prácticamente nos facilita a que cualquier clase pueda ser usada como categoría, pues no necesariamente los métodos tiene que ser estáticos y el contexto del argumento para la inyección es el objeto &lt;code&gt;this&lt;/code&gt; en donde se esté intentando usar.&lt;/p&gt;

&lt;h2 id=&#34;uso-de-groovytime:e62c0560695f1f5c3ac7c5a60edd4eb3&#34;&gt;Uso de GroovyTime&lt;/h2&gt;

&lt;p&gt;La clase &lt;code&gt;TimeCategory&lt;/code&gt; es una clase que tiene una serie de métodos de conveniencia para el manejo del tiempo, formando así un DSL, con el que podemos operar. Y con ayuda de la clase &lt;code&gt;Duration&lt;/code&gt; complementamos algunas operaciones que se pueden realizar en el contexto de los objetos que estemos usando.&lt;/p&gt;


    import groovy.time.TimeCategory

    use ( TimeCategory ) {
        println 2.hours.ago
        println 30.minutes.from // TimeDuration
        println 30.minutes.from.now
        println 40.minutes + 30.minutes.from.now
        println 30.minutes.ago

        def today = new Date()
        println today - 3.years
        println today + 4.weeks
        println today + 90.minutes
    }


&lt;p&gt;Para que consideres el conjunto de operaciones que tienes disponibles te recomendamos visitar la documentación de &lt;a href=&#34;http://groovy.codehaus.org/api/groovy/time/TimeCategory.html&#34;&gt;TimeCategory&lt;/a&gt; y &lt;a href=&#34;http://groovy.codehaus.org/api/groovy/time/Duration.html&#34;&gt;Duration&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lectura de correo con Apache Camel y Groovy</title>
      <link>http://blog.makingdevs.com/2014/08/26/lectura-de-correo-con-apache-camel-y-groovy</link>
      <pubDate>Tue, 26 Aug 2014 18:29:26 -0500</pubDate>
      
      <guid>http://blog.makingdevs.com/2014/08/26/lectura-de-correo-con-apache-camel-y-groovy</guid>
      <description>

&lt;p&gt;Hola a todos es un gusto contribuir al blog de makingdevs.com y mostrarles un poco de lo que es Apache Camel, para ellos hablaremos primero de su definición.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://camel.apache.org/&#34;&gt;Apache Camel&lt;/a&gt; es un framework de integración de código abierto, basado en &lt;a href=&#34;http://www.enterpriseintegrationpatterns.com/toc.html&#34;&gt;Enterprise Integration Patterns (Patrones de Integración Empresarial)&lt;/a&gt;. Camel nos permite definir las reglas de enrutamiento o mediación con ayuda de un lenguaje especifico (DSL), incluyendo un API basada en Java o mediante una configuración XML. El uso de un lenguaje específico del dominio significa que Apache Camel es capaz de soportar un comportamiento automático de las reglas de ruteo en un entorno de desarrollo integrado usando código Java sin gran cantidad de archivos de configuración XML.
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Con ayuda de camel y Mail Component (componente de e-mail de Camel) realize un script para la lectura de un correo Gmail, filtrando el procesamiento de los mismo por su subject y escupiendo el contenido a un endPoint de log.&lt;/p&gt;

&lt;p&gt;Pero si son curiosos ustedes se preguntaran &lt;strong&gt;¿Que es un endPoint?&lt;/strong&gt;. Un endpoint es la interface a través de la cual los sistemas externos pueden enviar y recibir mensajes, permitiendo así la integración de sistemas en Camel. La función de un endpoint es crear productores y consumidores, lo que nos permite usar este endpoint como to y from dentro de una ruta Camel. Asi se denota un endpoint URIs siguiendo el siguiente formato: &lt;strong&gt;[componente]:[contexto]?[opciones]&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;producers-y-consumers:5e76dbb3a6d52d4a33ab189790c5621d&#34;&gt;Producers y Consumers&lt;/h3&gt;

&lt;p&gt;Un productor es el encargado de proveer los mensajes, siendo el puente de comunicación con el sistema externo, no procesa la información solo provee el mensaje, en este ejemplo el correo es el productor. Un consumidor es el encargado de recibir el mensaje que el productor obtiene y así procesar el mensaje o inclusive partir dicho mensaje para que sea procesado por otro consumidor. Bueno después de una pequeña introducción a Camel les muestro mi script en la cual hago lectura del correo filtro los mensajes por su subject y los arrojo a un log y no solo puede ser un log gracias a camel este puede ser un bean, FTP, intancia de amazon, un archivo, &lt;a href=&#34;http://camel.apache.org/components.html&#34;&gt;casi cualquier cosa&lt;/a&gt;. Nota necesitamos las dependencias de camel core y camel mail para el siguiente ejemplo:&lt;/p&gt;


@Grab(group=&#39;org.apache.camel&#39;, module=&#39;camel-core&#39;, version=&#39;1.6.0&#39;)
@Grab(group=&#39;org.apache.camel&#39;, module=&#39;camel-mail&#39;, version=&#39;1.6.0&#39;)

import org.apache.camel.impl.DefaultCamelContext
import org.apache.camel.builder.RouteBuilder

def camelContext = new DefaultCamelContext()
camelContext.addRoutes(new RouteBuilder() {
  def void configure() {
    from(&#34;imaps://imap.gmail.com?username=user&#34;
    + &#34;&amp;password=password&#34;
    + &#34;&amp;deleteProcessedMessages=false&#34;
    + &#34;&amp;processOnlyUnseenMessages=true&#34;
    + &#34;&amp;consumer.delay=6000&#34;)
    .filter {it.in.headers.subject.contains(&#39;camel&#39;)}
    .to(&#34;log:groovymail?showAll=true&amp;multiline=true&#34;)
  }
})
camelContext.start()

addShutdownHook{ camelContext.stop() }
synchronized(this){ this.wait() }


&lt;p&gt;Notaran que al final del script hay una declaración &lt;code&gt;camelContext.start()&lt;/code&gt;. El &lt;em&gt;CamelContext&lt;/em&gt; representa una sola base de reglas de enrutamiento Camel. Se utiliza el CamelContext de una manera similar al ApplicationContext. Y asi tenemos un pequeño ejemplo de lectura de correo con ayuda de Camel.&lt;/p&gt;

&lt;p&gt;Como vemos Camel nos permite integrar sistemas muy facilmente. Espero les agradece este pequeño articulo y les sea de gran ayuda, dudas y comentarios son bienvenidas. Salu2&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>