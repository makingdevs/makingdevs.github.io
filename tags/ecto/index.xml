<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ecto on Blog de Making Devs</title>
    <link>http://blog.makingdevs.com/tags/ecto/</link>
    <description>Recent content in Ecto on Blog de Making Devs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 20 Sep 2016 19:35:08 -0500</lastBuildDate>
    <atom:link href="http://blog.makingdevs.com/tags/ecto/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ecto Transactions</title>
      <link>http://blog.makingdevs.com/2016/09/20/ecto-transactions</link>
      <pubDate>Tue, 20 Sep 2016 19:35:08 -0500</pubDate>
      
      <guid>http://blog.makingdevs.com/2016/09/20/ecto-transactions</guid>
      <description>&lt;p&gt;It has been a couple of months since I wrote something and was about &lt;code&gt;phoenix&lt;/code&gt; and &lt;code&gt;bootstrap&lt;/code&gt;. Today I&amp;rsquo;m going to talk about &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ecto&lt;/code&gt; and how to manage &lt;code&gt;transactions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Well in this post we are going to skip &lt;code&gt;ecto setup&lt;/code&gt; (if for some way, it was need it, please leave a comment and I will make a post for it, but I think his &lt;a href=&#34;https://github.com/elixir-ecto/ecto&#34;&gt;documentation&lt;/a&gt; makes a fairly good example for it)&lt;/p&gt;

&lt;p&gt;With that in mind, these are the tables that we are going to use.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Project table

defmodule EctoTransactions.Project do
  use Ecto.Schema
  import Ecto.Changeset

  schema &#34;projects&#34; do
    field :name
    has_many :tasks, EctoTransactions.Task

    timestamps
  end

  def changeset(struct, params \\ %{}) do
    struct
    |&gt; cast(params, [:name])
    |&gt; validate_required([:name])
  end

end
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Task table

defmodule EctoTransactions.Task do
  use Ecto.Schema

  import Ecto.Changeset

  schema &#34;tasks&#34; do
    field :description
    belongs_to :project, EctoTransactions.Project

    timestamps
  end

  def changeset(struct, params \\ %{}) do
    struct
    |&gt; cast(params, [:description, :project_id])
    |&gt; validate_required([:description, :project_id])
  end
end
&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With both tables we can see that &lt;code&gt;Task&lt;/code&gt; depends from &lt;code&gt;Project&lt;/code&gt;. So we are going to create a &lt;code&gt;project&lt;/code&gt; with a &lt;code&gt;task&lt;/code&gt; and we are going to see how can we handle a creation like that.&lt;/p&gt;

&lt;p&gt;The first thing we should know is, how can we create a transaction? With this instruction &lt;code&gt;Repo.transaction(fn -&amp;gt; end)&lt;/code&gt; Between &lt;code&gt;arrow&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; we put the code that we need. And for making a &lt;code&gt;rollback&lt;/code&gt; we use &lt;code&gt;Repo.rollback(value)&lt;/code&gt; and between parenthesis we can indicate the reason of why we are making that decision.&lt;/p&gt;

&lt;p&gt;So we are going to create a module for handling this&lt;/p&gt;


  defmodule EctoTransactions.App do

    import Ecto
    alias EctoTransactions.Repo
    alias EctoTransactions.Project
    alias EctoTransactions.Task

    # creating project and task
    def create_project_with_task(project_params, task_params) do
      Repo.transaction(fn -&gt;
        project_params
        |&gt; create_project_with_params
        |&gt; add_task_to_project(task_params)
      end)
    end

    # creating project
    defp create_project_with_params(project_params) do
      %Project{}
      |&gt; Project.changeset(project_params)
      |&gt; Repo.insert
    end

    # adding a task to a valid project
    defp add_task_to_project({:ok, project}, task_params) do
      changeset = project
                  |&gt; build_assoc(:tasks)
                  |&gt; Task.changeset(task_params)

      case Repo.insert(changeset) do
        {:ok, _task} -&gt; project
        {:error, changeset} -&gt; Repo.rollback(:task) # Rollback transaction for invalid task data
      end
    end
    defp add_task_to_project({:error, _changeset}, _task_params),
    do: Repo.rollback(:project) # Rollback transaction for invalid project data

  end


&lt;p&gt;So if we use &lt;code&gt;iex -S mix&lt;/code&gt; and passing some args to this we can obtain the following results&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Passing good options

iex(1)&gt; project_params = %{name: &#34;Explain ecto transactions&#34;}
%{name: &#34;Explain ecto transactions&#34;}
iex(2)&gt; task_params = %{description: &#34;Should create task for example&#34;}
%{description: &#34;Should create task for example&#34;}
iex(3)&gt; EctoTransactions.App.create_project_with_task(project_params, task_params)

22:28:59.905 [debug] QUERY OK db=0.2ms queue=0.1ms
begin []

22:28:59.917 [debug] QUERY OK db=0.9ms
INSERT INTO &#34;projects&#34; (&#34;name&#34;,&#34;inserted_at&#34;,&#34;updated_at&#34;) VALUES ($1,$2,$3) RETURNING &#34;id&#34; [&#34;Explain ecto transactions&#34;, {{2016, 9, 21}, {3, 28, 59, 0}}, {{2016, 9, 21}, {3, 28, 59, 0}}]

22:28:59.921 [debug] QUERY OK db=3.1ms
INSERT INTO &#34;tasks&#34; (&#34;description&#34;,&#34;project_id&#34;,&#34;inserted_at&#34;,&#34;updated_at&#34;) VALUES ($1,$2,$3,$4) RETURNING &#34;id&#34; [&#34;Should create task for example&#34;, 1, {{2016, 9, 21}, {3, 28, 59, 0}}, {{2016, 9, 21}, {3, 28, 59, 0}}]

22:28:59.922 [debug] QUERY OK db=0.3ms
commit []
{:ok,
 %EctoTransactions.Project{__meta__: #Ecto.Schema.Metadata&lt;:loaded, &#34;projects&#34;&gt;,
  id: 1, inserted_at: #Ecto.DateTime&lt;2016-09-21 03:28:59&gt;,
  name: &#34;Explain ecto transactions&#34;,
  tasks: #Ecto.Association.NotLoaded&lt;association :tasks is not loaded&gt;,
  updated_at: #Ecto.DateTime&lt;2016-09-21 03:28:59&gt;}}
&lt;/li&gt;
&lt;/ul&gt;


ecto_simple&gt; select * from projects; select * from tasks;
+------+---------------------------+---------------------+---------------------+
|   id | name                      | inserted_at         | updated_at          |
|------+---------------------------+---------------------+---------------------|
|    1 | Explain ecto transactions | 2016-09-21 03:28:59 | 2016-09-21 03:28:59 |
+------+---------------------------+---------------------+---------------------+
SELECT 1
+------+--------------------------------+--------------+---------------------+---------------------+
|   id | description                    |   project_id | inserted_at         | updated_at          |
|------+--------------------------------+--------------+---------------------+---------------------|
|    1 | Should create task for example |            1 | 2016-09-21 03:28:59 | 2016-09-21 03:28:59 |
+------+--------------------------------+--------------+---------------------+---------------------+
SELECT 1
Time: 0.003s


&lt;p&gt;And for bad data we can obtain next results:&lt;/p&gt;


iex(4)&gt; project_params = %{name: 1}
%{name: 1}
iex(5)&gt; task_params = %{description: nil}
%{description: nil}
iex(6)&gt; EctoTransactions.App.create_project_with_task(project_params, task_params)

22:49:25.863 [debug] QUERY OK db=0.2ms
begin []

22:49:25.865 [debug] QUERY OK db=0.2ms
rollback []
{:error, :project}

iex(7)&gt; project_params = %{name: &#34;Explain ecto transactions&#34;}
%{name: &#34;Explain ecto transactions&#34;}
iex(8)&gt; EctoTransactions.App.create_project_with_task(project_params, task_params)

22:49:53.345 [debug] QUERY OK db=0.3ms queue=0.1ms
begin []

22:49:53.346 [debug] QUERY OK db=1.2ms
INSERT INTO &#34;projects&#34; (&#34;name&#34;,&#34;inserted_at&#34;,&#34;updated_at&#34;) VALUES ($1,$2,$3) RETURNING &#34;id&#34; [&#34;Explain ecto transactions&#34;, {{2016, 9, 21}, {3, 49, 53, 0}}, {{2016, 9, 21}, {3, 49, 53, 0}}]
#Ecto.Changeset&lt;action: :insert, changes: %{},
 errors: [description: {&#34;can&#39;t be blank&#34;, []}], data: #EctoTransactions.Task&lt;&gt;,
 valid?: false&gt;

22:49:53.348 [debug] QUERY OK db=0.2ms
rollback []
{:error, :task}
iex(9)&gt;


&lt;p&gt;If you read with attention you will see two tupples &lt;code&gt;{:error, :project}&lt;/code&gt; and &lt;code&gt;{:error, :task}&lt;/code&gt; with this you can make the assumptions that you want, of course you could say a lot more and instead of returning tupples you return other things with more sense for example change &lt;code&gt;:project&lt;/code&gt; or &lt;code&gt;:task&lt;/code&gt; for his respective &lt;code&gt;changeset&lt;/code&gt; and you should see other things.&lt;/p&gt;

&lt;p&gt;By the way when use &lt;code&gt;Repo.transaction&lt;/code&gt; you should return the implicit data (that is the schema you are saving) that&amp;rsquo;s because &lt;code&gt;Repo.transaction&lt;/code&gt; return a tupple consisting of an &lt;code&gt;:ok&lt;/code&gt; atom and the respective last instruction. And if you use &lt;code&gt;Repo.insert&lt;/code&gt; as returning data you will see a tupple of tupple &lt;code&gt;{:ok, {:ok, data}}&lt;/code&gt; or &lt;code&gt;{:ok, {:error, data}}&lt;/code&gt; (thats because the return of an insert is &lt;code&gt;{:ok, data}&lt;/code&gt; or &lt;code&gt;{:error, data}&lt;/code&gt;) and that&amp;rsquo;s why we use &lt;code&gt;Repo.rollback&lt;/code&gt; for forcing a tupple consisting of &lt;code&gt;{:error, reason}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all folks! I hope this can help you. And remember Good Luck, Have Fun! and GG!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>